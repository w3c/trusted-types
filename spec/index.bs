<!--
Before editing this document, please see
https://github.com/WICG/trusted-types/blob/master/README.md#spec-changes
-->

<pre class='metadata'>
Title: Trusted Types
Shortname: trusted-types
Group: WICG
Level: none
Status: CG-DRAFT
URL: https://wicg.github.io/trusted-types/dist/spec/
Editor: Krzysztof Kotowicz, Google LLC https://google.com, koto@google.com
Editor: Mike West, Google LLC https://google.com, mkwst@google.com
Repository: WICG/trusted-types
Abstract: An API that allows applications to lock down DOM XSS injection sinks to only accept non-spoofable, typed values in place of strings.
Markup Shorthands: algorithm yes, biblio yes, css no, dfn yes, markdown yes, markup yes
Ignored Terms: h1, h2, h3, h4, h5, h6, xmp, EmptyString
Complain About: missing-example-ids yes
<!-- WPT Path Prefix: /trusted-types/ # Cannot add this, as it requires all the tests to be referenced in the spec -->
</pre>

<pre class="anchors">
urlPrefix: https://html.spec.whatwg.org/multipage/common-dom-interfaces.html; type: dfn; spec: HTML
    text: reflect
url: https://www.w3.org/TR/DOM-Parsing/#h-the-domparser-interface; type: enum; spec: DOM-Parsing
    text: SupportedType
</pre>

<!-- TODO
Complain About: broken-links yes
-->

# Introduction # {#introduction}

*This section is not normative.*

DOM-Based Cross-Site Scripting (DOM XSS) occurs when a web application
takes a string value from an attacker-controlled source (e.g. the
document URL parameter, or postMessage channel) and passes that value
to one of the [[#injection-sinks|injection sinks]], that eventually causes execution of the
script payload controlled by the attacker.

This vulnerability type is prevalent in the web applications for two
reasons. For one, it's easy to introduce - there are over 60 different
injection sinks (e.g. `Element.innerHTML`, or `Location.href` setters).
A lot of those sinks are widely used, and are often passed an attacker-controlled
value without the developer realizing it. Secondly, DOM XSS is
difficult to prevent. Due to the dynamic nature of JavaScript it's
difficult to ascertain that this vulnerability is not present in a
given program - as such, DOM XSS is often missed during manual code
reviews, and automated code analysis. As an example,
`foo[bar] = aString` is a statement that potentially introduces DOM XSS.

This document defines [[#trusted-types|Trusted Types]] - an API that allows applications
to lock down DOM XSS injection sinks to only accept non-spoofable, typed values
in place of strings. These values can in turn only be created from
application-defined [[#policies|policies]], allowing the authors to define rules
guarding writing values to the DOM, and reducing the DOM XSS attack
surface to small, isolated parts of the web application codebase,
which are substantially easier to safeguard, monitor and review.


## Goals ## {#goals}

*   Minimize the likelihood of accidental DOM XSS introduction by the authors.

*   Encourage a design in which XSS-related security decisions are
    encapsulated within a small part of the application.

*   Reduce DOM XSS security review surface for complex web application codebases.


## Non-goals ## {#non-goals}

*   Address injections into server-side generated markup, in specific
    reflections into the body of the scripts running in a document.

Issue:  mention other solutions, like templating systems, or CSP for mitigating


## Use cases ## {#use-cases}

Issue: figure out if we need this section here. CSP has none, SRI has one and it looks useful.

*   An author maintains a complex web application written in a framework
    that uses a secure templating system to generate the UI
    components. The application also depends on 3rd party client-side
    libraries that perform auxiliary tasks (e.g. analytics, performance
    monitoring). To ensure that none of these components introduces DOM
    XSS vulnerabilities, author defines a Trusted Type policy in the
    templating policy and enables the enforcement for the DOM sinks.
*   Issue: Something about reducing the review surface


# Framework # {#framework}

## Injection sinks ## {#injection-sinks}

*This section is not normative.*

A DOM XSS <dfn>injection sink</dfn> is a function that evaluates an input
string value in a way that could result in XSS if that value is untrusted.

Examples of injection sinks include:

  * Functions that parse & insert HTML strings into he document like
    [[DOM-Parsing#widl-Element-innerHTML|Element.innerHTML]] setter
  * Setters for {{Element}} attributes that accept a URL of the code to load
    like {{HTMLScriptElement/src!!attribute|HTMLScriptElement.src}}
  * Setters for {{Element}} attributes that accept a code to execute like
    {{HTMLScriptElement/text!!attribute|HTMLScriptElement.text}}
  * Functions that execute code directly like `eval`.
  * Functions that accept URLs with `javascript:` scheme
  * Functions that create a new same-origin {{Document}} with caller-controlled
    markup like {{DOMParser/parseFromString()}}.

An application is vulnerable to DOM XSS if it permits a flow of data from an
attacker-controlled source and permits that data to reach an injection sink
without appropriate validation, sanitization or escaping.

It's difficult to determine if DOM XSS is present by analyzing the invocations
of [=injection sinks=], as the strings do not carry the information about the
provenance of their value. To allow the authors to control values reaching
sensitive DOM and JavaScript functions, we introduce Trusted Types.

Note: The exact list of injection sinks covered by this document is defined in
[[#integrations]].

Issue(WICG/trusted-types#43): Consider surfacing the DOM sink (node + attr) => type mapping in the API, to faciliate building HTML sanitizers.


## Trusted Types ## {#trusted-types}

We introduce the following list of
<dfn>Trusted Type</dfn>s indicating that a given value is
trusted by the authors to be used with an [=injection sink=] in a certain context.

Note: **Trusted** in this context signifies the fact that the application author
is confident that a given value can be safely used with an injection sink - she
*trusts* it does not introduce a vulnerability. That does not imply that the
value is indeed *safe*.

Note: This allows the authors to specify the intention when creating a given
value, and the user agents to introduce checks based on the type of
such value to preserve the authors' intent. For example, if the
authors intends a value to be used as a URL of an image, an attempt to
load a script from that URL would fail.

Note: All Trusted Types wrap over an immutable string, specified when the
objects are created. These objects are unforgable in a sense that
there is no JavaScript-exposed way to replace the inner string value
of a given object - it's stored in an internal slot with no setter
exposed.

Note: All Trusted Types stringifiers return the inner string value.
This makes it easy to incrementally migrate the application code into using
Trusted Types in place of DOM strings (it's possible to start
producing types in parts of the application, while still using and
accepting strings in other parts of the codebase). In that sense,
Trusted Types are backwards-compatible with the regular DOM APIs.

### TrustedTypes extended attribute

To ensure that Trusted Types are required in DOM property setters [=injection sinks=], we introduce
<dfn data-dfn-type="extended-attribute" data-x="TrustedTypes" data-lt="TrustedTypes"><code>[TrustedTypes]</code></dfn>
IDL [=extended attributes|extended attribute=]. It indicates that the relevant setter algorithm is to be supplemented with additional
enforcing steps.

The {{TrustedTypes}} extended attribute [=extended attribute/takes an identifier=] as an argument.
The only valid values for the identifier are {{TrustedHTML}}, {{TrustedScript}}, {{TrustedScriptURL}} or {{TrustedURL}}.
This extended attribute must not appear on anything other than an attribute or an [=operation=] argument.
Additionally, it must not appear on readonly attributes.

When the extended attribute appears on an attribute, the setter for that attribute must run the following steps in place of the ones specified in their description:

 1. If [=relevant global object=] has an [=associated document=]:
    1. Set *value* to the result of running the [$Get Trusted Type compliant string$] algorithm, with *input* being the new value, *expectedType* being the {{TrustedType}} extended attribute [=identifier=], and *document* being the [=relevant global object=]'s [=associated document=].
    1. If an exception was thrown, rethrow exception and abort further steps.
 1. Run the originally specified steps for this construct, using *value* as a new value to set.

Note: If the IDL attribute [=reflect/reflects=] a given content attribute, identical steps should be performed when the content attribute is modified by JavaScript code e.g. via ''Element.setAttribute()'' function.

When the extended attribute appears on an [=operation=] argument, before its operation is invoked, run the following steps:

 1. If [=relevant global object=] has an [=associated document=]:
    1. Set the new argument value to the result of running the [$Get Trusted Type compliant string$] algorithm, with *input* being the argument value, *expectedType* being the {{TrustedType}} extended attribute [=identifier=], and *document* being the [=relevant global object=]'s [=associated document=].
    1. If an exception was thrown, rethrow exception and abort further steps.
 1. Invoke the originally specified steps for the operation.


### <dfn type>TrustedHTML</dfn> ### {#trusted-html}

The TrustedHTML interface represents a string that a developer can
confidently insert into an [=injection sink=] that will render it as HTML.
These objects are immutable
wrappers around a string, constructed via a {{TrustedTypePolicy}}'s
{{TrustedTypePolicy/createHTML(input)|createHTML}} method.

<pre class="idl">
[Exposed=Window]
interface TrustedHTML {
  stringifier;
};
</pre>

TrustedHTML objects have a `[[Data]]` internal slot which holds a
DOMString. The slot's value is set when the object is created, and
will never change during its lifetime.

To stringify a TrustedHTML object, return the DOMString from its
`[[Data]]` internal slot.

Issue(WICG/trusted-types#95): Add TrustedHTML.EMPTY.

### <dfn type>TrustedScript</dfn> ### {#trusted-script}

The TrustedScript interface represents a string with an uncompiled
script body that a developer can confidently pass into an [=injection sink=]
that might lead to executing that script.
These objects are immutable wrappers
around a string, constructed via a {{TrustedTypePolicy}}'s
{{TrustedTypePolicy/createScript(input)|createScript}} method.

<pre class="idl">
[Exposed=Window]
interface TrustedScript {
  stringifier;
};
</pre>

TrustedScript objects have a `[[Data]]` internal slot which holds a
DOMString. The slot's value is set when the object is created, and
will never change during its lifetime.

To stringify a TrustedScript object, return the DOMString from its
`[[Data]]` internal slot.


### <dfn type>TrustedScriptURL</dfn> ### {#trused-script-url}

The TrustedScriptURL interface represents a string that a developer
can confidently pass into an [=injection sink=] that will parse it as a URL of
an external script resource.
These objects are immutable wrappers around a
string, constructed via a {{TrustedTypePolicy}}'s
{{TrustedTypePolicy/createScriptURL(input)|createScriptURL}} method.

<pre class="idl">
[Exposed=Window]
interface TrustedScriptURL {
  stringifier;
};
</pre>

TrustedScriptURL objects have a `[[Data]]` internal slot which holds a
USVString. The slot's value is set when the object is created, and
will never change during its lifetime.

To stringify a TrustedScriptURL object, return the USVString from its
`[[Data]]` internal slot.


### <dfn type>TrustedURL</dfn> ### {#trusted-url}

The TrustedURL interface represents a string that a developer
can confidently pass into an [=injection sink=] that will be parse it a URL of
an external resource that is not scripted.
These objects are immutable wrappers around a
string, constructed via a {{TrustedTypePolicy}}'s
{{TrustedTypePolicy/createURL(input)|createURL}} method.

<pre class="idl">
[Exposed=Window]
interface TrustedURL {
  stringifier;
};
</pre>

TrustedURL objects have a `[[Data]]` internal slot which holds a
USVString.  The slot's value is set when the object is created, and
will never change during its lifetime.

To stringify a TrustedURL object, return the USVString from its
`[[Data]]` internal slot.

Issue(WICG/trusted-types#104): Consider adding new set of types, e.g. related to CSS.

## Policies ## {#policies}

Trusted Types can only be created via user-defined
and immutable policies that define rules for converting a string into
a given Trusted Type object. Policies allows the authors to specify custom,
programmatic rules that Trusted Types must adhere to.

<div class="example" id="sanitizing-policy">
Authors may define a
policy that will sanitize an HTML string, allowing only a subset of
tags and attributes that are known not to cause JavaScript
execution. Any {{TrustedHTML}} object created through this policy can then
be safely used in the application, and e.g. passed to `innerHTML`
setter - even if the input value was controlled by the attacker, the
policy rules neutralized it to adhere to policy-specific
contract.
<xmp highlight=js>
const sanitizingPolicy = TrustedTypes.createPolicy('sanitize-html', {
  createHTML: (input) => myTrustedSanitizer(input, { superSafe: 'ok'}),
});

myDiv.innerHTML = sanitizingPolicy.createHTML(untrustedValue);
</xmp>
</div>

Note: [=Trusted Type=] objects wrap values that are explicitly trusted by
the author. As such, creating a Trusted Type object instance becomes a de
facto DOM XSS [=injection sink=], and hence code that creates Trusted Type
instances is security-critical. To allow for strict control over Trusted Type
object creation we don't expose the constructors of those
directly, but require policy usage.

There can be multiple policies for a document, allowing the
applications to define different rules for different parts of the
codebase.

<div class="example" id="policy-reference">
Library initialized with a policy allowing it to load additional scripts from
a given host.
<xmp highlight=js>

const cdnScriptsPolicy = TrustedTypes.createPolicy('cdn-scripts', {
  createScriptURL(url) {
    const parsed = new URL(url, document.baseURI);
    if (parsed.origin == 'https://mycdn.example') {
      return url;
    }
    throw new TypeError('invalid URL');
  },
});

myLibrary.init({policy: cdnScriptsPolicy});
</xmp>
</div>

Note: As Trusted Type objects can only be created via policies, if
[=enforcement=] is enabled, only the policy code can introduce a DOM
XSS, and hence call-sites of the policies' factory functions are the
*only* security-sensitive code in the entire program. Only this
typically small subset of the entire code base needs to be
security-reviewed for DOM XSS - there's no need to monitor or review
the traditional DOM sinks, as User Agents [=enforcement|enforce=] that
those sinks will only accept Trusted Type objects, and these in turn
can only be created via policies.

The {{TrustedTypePolicyFactory/createPolicy()|createPolicy}} function returns a policy object whose create\* functions
will create Trusted Type objects after applying the policy
rules.

Note: While it's safe to expose a policy that sanitizes its input
(and allow any part of the application to use it), there might be a
need to create lax policies to be used internally, and only to be
called with author-controlled input. For example, a client-side HTML
templating library, an HTML sanitizer library, or a JS asynchronous
code plugin loading subsystem each will likely need full control over
HTML or URLs. The API design facilitates that - each policy may only
be used if the callsite can obtain a reference to the policy (a return
value from {{TrustedTypePolicyFactory/createPolicy()}}). As such, policy
references can be treated as
<a href="https://en.wikipedia.org/wiki/Object-capability_model">capabilities</a>,
access to which can be controlled using JavaScript techniques
(e.g. via closures, internal function variables, or modules).

<div class="example" id="policy-capability">
Unsafe no-op policy reachable only from within a single code block to ascertain
that it's called only with no attacker-controlled values.
<xmp highlight=js>
(function renderFootnote() {
  const unsafePolicy = TrustedTypes.createPolicy('html', {
    createHTML: input => input,
  });
  const footnote = await fetch('/footnote.html').then(r => r.text());
  footNote.innerHTML = unsafePolicy.createHTML(footnote);
})();
</xmp>
</div>

### <dfn type>TrustedTypePolicyFactory</dfn> ### {#trusted-type-policy-factory}

TrustedTypePolicyFactory creates
{{TrustedTypePolicy|policies}} and verifies that Trusted Type object instances
were created via one of the policies.

Note: This factory object is exposed to JavaScript through `window.TrustedTypes`
reference - see [[#extensions-to-the-window-interface]].

<pre class="idl">
[Exposed=Window] interface TrustedTypePolicyFactory {
    [Unforgeable] TrustedTypePolicy createPolicy(
        DOMString policyName, optional TrustedTypePolicyOptions policyOptions);
    [Unforgeable] sequence&lt;DOMString> getPolicyNames();
    [Unforgeable] boolean isHTML(any value);
    [Unforgeable] boolean isScript(any value);
    [Unforgeable] boolean isScriptURL(any value);
    [Unforgeable] boolean isURL(any value);
    [Unforgeable] readonly attribute TrustedHTML emptyHTML;
};
</pre>

Internal slot `[[PolicyMap]]` contains a map, with each map entry
being a pair of a policy name (DOMString key) and the
TrustedTypePolicy (value).

Internal slot `[[Configuration]]` stores the {{TrustedTypeConfiguration}}
to be applied for documents the factory is created for.

<div dfn-type="method" dfn-for="TrustedTypePolicyFactory">

:   <dfn>createPolicy(policyName, policyOptions)</dfn>
::  Creates a uniquely named policy object that will implement the rules
    passed in the {{TrustedTypePolicyOptions}} object. Allowed policy names
    may be restricted by the [=Trusted-Types HTTP Response Header=] - if that
    is present, and the policy name is not on the whitelist defined in the
    header, the policy creation fails with a [[WebIDL-1#idl-Error|TypeError]].
    Also, if createPolicy is called more than once with any given policyName,
    policy creation fails with a TypeError.

    <div class="example" id="create-policy-example">
    <xmp highlight=js>
    // HTTP Response header: Trusted-Types: "foo"
    TrustedTypes.createPolicy("foo", {}); // ok.
    TrustedTypes.createPolicy("bar", {}); // throws - name not on the whitelist.
    TrustedTypes.createPolicy("foo", {}); // throws - duplicate name.
    </xmp>
    </div>

    Returns the result of executing a [$Create a Trusted Type Policy$] algorithm,
    with the following arguments:
    <dl>
    <dt>factory</dt>
    <dd>[[DOM#context-object|context object]]</dd>
    <dt>policyName</dt>
    <dd>policyName</dt>
    </dl>

: <dfn>getPolicyNames()</dfn>
::  Returns a new list, comprising of all keys of the `[[PolicyMap]]`
    internal slot map.

: <dfn>isHTML(value)</dfn>
:: Returns true if value is an instance of {{TrustedHTML}} and has its `[[Data]]`  internal slot set, false otherwise.

    Note: `is*` functions are used to check if a given object is truly a legitimate
    [=Trusted Type=] object (e.g. it was created via one of the configured
    policies). This is to be able to detect a forgery of the objects via
    e.g. [[ECMASCRIPT#sec-object.create|Object.create]]
    or prototype chains manipulation.

    <div class="example" id="is-html-example">
    <xmp highlight=js>
    const html = policy.createHTML('<div>');
    TrustedTypes.isHTML(html) // true

    const fake = Object.create(TrustedHTML.prototype);
    TrustedTypes.isHTML(fake) // false

    TrustedTypes.isHTML("<div>plain string</div>") // false
    </xmp>
    </div>


: <dfn>isScript(value)</dfn>
:: Returns true if value is an instance of {{TrustedScript}} and has its `[[Data]]` internal slot set, false otherwise.

: <dfn>isScriptURL(value)</dfn>
:: Returns true if value is an instance of {{TrustedScriptURL}} and has its `[[Data]]` internal slot set, false otherwise.

: <dfn>isURL(value)</dfn>
:: Returns true if value is an instance of {{TrustedURL}} and has its `[[Data]]` internal slot set, false otherwise.

</div>

<div class="example" id="create-and-used-unexposed-policy">
<xmp highlight="js">
const myPolicy = TrustedTypes.createPolicy('myPolicy', {
  // This needs security review, as it's security critical code;
  // a flaw in this code could cause DOM XSS.
  createHTML(input) { return ASanitizer.sanitize(input) },
  createScriptURL(input) {
    const u = new URL(dirty, document.baseURI);
    if (APPLICATION_CONFIG.scriptOrigins.includes(u.origin)) {
      return u.href;
    }
    throw new Error('Cannot load scripts from this origin');
  },
});
TrustedTypes.getPolicyNames();
// ['myPolicy']

document.querySelector("#foo").innerHTML = myPolicy.createHTML(aValue);
scriptElement.src = myPolicy.createScriptURL(
    'https://scripts.myapp.example/script.js');
</xmp>
</div>

<div dfn-type="attribute" dfn-for="TrustedTypePolicyFactory">

: <dfn>emptyHTML</dfn>
:: is a {{TrustedHTML}} object with its `[[Data]]` internal slot value set to an empty string.

</div>

### <dfn type>TrustedTypePolicy</dfn> ### {#trusted-type-policy}

Policy objects implement a TrustedTypePolicy interface and define a
group of functions creating Trusted Type objects. Each policy is
identified by a name unique within a realm. Each of the create
functions converts a string value to a given Trusted Type variant, or
throws a TypeError if a conversion of a given value is disallowed.

<pre class="idl">
[Exposed=Window]
interface TrustedTypePolicy {
  [Unforgeable] readonly attribute DOMString name;
  [Unforgeable] TrustedHTML createHTML(DOMString input);
  [Unforgeable] TrustedScript createScript(DOMString input);
  [Unforgeable] TrustedScriptURL createScriptURL(DOMString input);
  [Unforgeable] TrustedURL createURL(DOMString input);
};
</pre>

Each TrustedTypePolicy object has an `[[options]]` internal slot, holding the {{TrustedTypePolicyOptions}} object describing the actual behavior of the policy.

<div dfn-type="method" dfn-for="TrustedTypePolicy">

: <dfn>createHTML(input)</dfn>
::  Returns the
    result of executing the [$Create a Trusted Type$] algorithm, with the
    following arguments:
    <dl>
      <dt>policy</dt>
      <dd>[[DOM#context-object|context object]]</dt>
      <dt>trustedTypeName</dt>
      <dd>`"TrustedHTML"`</dd>
      <dt>value</dt>
      <dd>input</dd>
    </dl>

: <dfn>createScript(input)</dfn>
::  Returns the
    result of executing the [$Create a Trusted Type$] algorithm, with the
    following arguments:
    <dl>
      <dt>policy</dt>
      <dd>[[DOM#context-object|context object]]</dt>
      <dt>trustedTypeName</dt>
      <dd>`"TrustedScript"`</dd>
      <dt>value</dt>
      <dd>input</dd>
    </dl>


: <dfn>createScriptURL(input)</dfn>
::  Returns the
    result of executing the [$Create a Trusted Type$] algorithm, with the
    following arguments:
    <dl>
      <dt>policy</dt>
      <dd>[[DOM#context-object|context object]]</dt>
      <dt>trustedTypeName</dt>
      <dd>`"TrustedScriptURL"`</dd>
      <dt>value</dt>
      <dd>input</dd>
    </dl>


: <dfn>createURL(input)</dfn>
::  Returns the
    result of executing the [$Create a Trusted Type$] algorithm, with the
    following arguments:
    <dl>
      <dt>policy</dt>
      <dd>[[DOM#context-object|context object]]</dt>
      <dt>trustedTypeName</dt>
      <dd>`"TrustedURL"`</dd>
      <dt>value</dt>
      <dd>input</dd>
    </dl>


</div>

### <dfn type>TrustedTypePolicyOptions</dfn> ### {#trusted-type-policy-options}

This dictionary holds author-defined functions for converting string
values into trusted values. These functions do not create [=Trusted Type=]
object instances directly - this behavior is provided by
{{TrustedTypePolicy}}.

<pre class="idl">
dictionary TrustedTypePolicyOptions {
   CreateHTMLCallback? createHTML;
   CreateScriptCallback? createScript;
   CreateURLCallback? createURL;
   CreateScriptURLCallback? createScriptURL;
};
callback CreateHTMLCallback = DOMString (DOMString input);
callback CreateScriptCallback = DOMString (DOMString input);
callback CreateURLCallback = USVString (DOMString input);
callback CreateScriptURLCallback = USVString (DOMString input);
</pre>

### <dfn>Default policy</dfn> ### {#default-policy-hdr}

*This section is not normative.*

One of the policies, the "default" policy, is special; while all other
policies have to be called explicitly to create a TrustedType object,
the default policy can also be called implicitly by the user agent. It
allows the application to define the rules that should be run as a
fallback, in case an [=injection sink=] is passed a string (instead of a
Trusted Type object).

This optional behavior allows for introducing Trusted Type [=enforcement=]
to applications that are still using legacy code that writes to the DOM
(or calls `eval`) directly. Needless to say, this policy should
necessarily be defined with very strict rules not to introduce a DOM
XSS vulnerability in unknown parts of the application. In an extreme
case, a lax, no-op default policy could bring the application DOM XSS
security posture back to the pre-Trusted Types level. If possible,
authors should resort to a default policy in a transitional period
only, use it to detect and rewrite "raw DOM writes" dependencies and
eventually phase out its usage entirely.

Note: See [[#get-trusted-type-compliant-string-algorithm]] for details on how
the default policy is applied.


## <dfn>Enforcement</dfn> ## {#enforcement-hdr}

This section describes how applications may require [=Trusted Types=] values for
their [=injection sinks=] via specifying a HTTP response header, and what
actions should be undertaken if a string value is used instead.

Note: Enforcement is the process of checking that a value
has an appropriate type before it reaches an [=injection sink=].

Note: Most of the enforcement rules are defined as modifications of the algorithms
in other specifiactions, see [[#integrations]].

### TrustedTypeConfiguration ### {#trusted-type-configuration-hdr}

A Trusted Type Configuration defines [=enforcement=] setting for
[=Trusted Types=] and restrictions on policy names that can be applied
to a {{Document}}.

<pre class="idl">
enum StringAtSinkDisposition {
  "reject",
  "report",
  "unsafe-allow",
};

enum UnknownPolicyNameDisposition {
  "reject",
  "allow",
};

dictionary TrustedTypeConfiguration {
  UnknownPolicyNameDisposition unknownPolicyName = "allow";
  StringAtSinkDisposition? domSinks;
  sequence&lt;DOMString> allowedNames;
  DOMString reportingGroup = "default";
};
</pre>

Each Trusted Type Configuration has an associated
{{StringAtSinkDisposition|string at sink disposition}}
(for all DOM sinks).
It is either “reject”, “report” or “unsafe-allow”.

Each Trusted Type Configuration has an associated
{{UnknownPolicyNameDisposition|unknown policy name disposition}},
which is either “reject” or “allow”.

Each Trusted Type Configuration has an associated allowed policy names set.

Each Trusted Type Configuration has a related reporting group name.

Issue(WICG/trusted-types#36): Decide if it should be possible from JS to determine if types are enforced without resorting to `try {} catch`.

### <dfn http-header>Trusted-Types</dfn> HTTP Response Header ### {#trusted-types-http-header}

Issue(WICG/trusted-types#1): In the current Chromium implementation, the enforcement mechanism is
configured in the `Content-Security-Policy` header (instead of `Trusted-Types`), with slightly different syntax. See [explainer](https://github.com/WICG/trusted-types#limiting-policies) and [platform test files](https://github.com/web-platform-tests/wpt/tree/master/trusted-types).

Issue: +mkwst The header does not appear in the origin trials.  Can
the spec differ so much from the implementation, especially given the
upcoming Origin Trials?

The <dfn>Trusted-Types HTTP response header</dfn> instructs the user agent
to apply a particular configuration of the Trusted Types framework to
the document created from a given response. Specifically, the header
value defines which policies (identified by name) can be created by
the application, and what should be the behavior when a string value
is passed to an [=injection sink=] (e.g. should the type-based enforcement be
enabled, or whether to attempt implicit conversion with a default
policy).

The header value is a serialized Trusted Types configuration
represented by the following ANBF:

<xmp highlight="abnf">
TRUSTEDTYPES = json-field-value
</xmp>

The header’s value is interpreted as a JSON-formatted array of values
without the outer `[` and `]`, as described in Section 4 of
[[HTTP-JFV]].

Note: The header syntax is tailored to making a secure configuration
simple, while allowing explicit change towards less strict
configurations possible.

<div class="example" id="whitelist-of-policy-names-in-header">
Types are enforced at sinks, and only policies name “one” and “two”
may be created.

<pre class="http">
Trusted-Types: "one", "two"
</pre>
</div>

<div class="example" id="header-that-allows-no-policy-names">
A value of `null` indicates policies may not be created, and sinks are
enforced.  I.e. no [=injection sinks=] can be used in a document.

<pre class="http">
Trusted-Types: null
</pre>
</div>

A policy named `"*"` makes it possible to create policies with any
previously unused name.

<div class="example" id="wildcard-policy-name-in-header">
<pre class="http">
Trusted-Types: "*"
</pre>
</div>

If the policy named `“default”` is present in the list, it refers to the
[=default policy=], and unless otherwise configured,
all strings passed to [=injection sinks=] will be passed through it instead
of being rejected outright.

<div class="example" id="default-in-header">
<pre class="http">
Trusted-Types: "one", "two", "default"
</pre>
</div>

To specify more fine-grained control over the enforcement, authors can
use a header value that is an object. That object allows for configuring the
enforcement for the [=injection sinks=].

<div class="example" id="complex configuration-in-header">
Only reports violations in [=injection sinks=], but allow strings passed to them
(similar to Content-Security-Policy-Report-Only).
<pre class="http" id="string-at-sink-disposition-in-header">
Trusted-Types: "*", {"dom”: "unsafe-allow"}
</pre>

Report violations using a “trustedtypes” reporting group.
<pre class="http" id="reporting-group-in-header">
Trusted-Types: "*", {"report": "trustedtypes"}
</pre>

Explicitly specify that a string passed to an [=injection sink=] requiring
any Trusted Type should be rejected.  This is the default behavior if the
header is present.
<pre class="http" id="unknown-policy-name-disposition-in-header">
Trusted-Types: "*", {"dom": "reject"}
</pre>
</div>

Issue(WICG/trusted-types#66): Decide if separate per-type enforcement settings should be exposed to the authors.

Issue: it seems to be the case that one object is allowed and it should
appear last, it cannot contain an allowedNames property and the allowedNames
set should be the string values.  Clarify.

Issue: maybe treat a string as a configuration that is equivalent to a
configuration that allows just that name and which has the default values
for the other properties and allow `{"allowedNames":[...],...}`.
This would enable a use case where migrating one tool at a time by having
some policies that are report-only and others that are enforced.

Issue: if so, need example of 2 disjoint allowed name sets with different
configurations.

Issue: what happens if there are 2 configurations with overlapping
allowed name sets?

Issue: does a single configuration with an unknown policy name disposition
of "allow" govern all policy names that appear in no other configuratons.



### Violation ### {#violation}

A violation represents an action which is disallowed by the
{{TrustedTypeConfiguration}} objects associated with the {{Document}}.

Issue: how does this relate to webappsec-csp/[=Violation=]?

Issue: TODO: Describe the properties of the violation
Each violation has a configuration , which is a Trusted Type Configuration.
Each violation has a global object , which is a global object.

Issue: TODO(mkwst): How to serialize? CSP3 has no serialization defined for
the violation object, although reporting assumes the object should be
serializable.


### Reporting ### {#reporting}

Issue: How does a policy violation get reported (both at the sink
level, and when creating a policy).

# Algorithms # {#algorithms}

## Policies ## {#policy-algorithms}

### <dfn abstract-op>Initialize policy factory</dfn> ### {#initialize-policy-factory-algorithm}

To initialize a {{TrustedTypePolicyFactory|Trusted Type Factory}} with a
{{TrustedTypeConfiguration}} run these steps:

1.  Let *factory* be a new {{TrustedTypePolicyFactory}} object, with an empty `[[PolicyMap]]` map.
1.  Set the *factory*'s `[[Configuration]]` internal slot to *configuration*.
1.  Return *factory*.

Issue: does configuration need to be defensively copied.

### <dfn abstract-op>Create a Trusted Type Policy</dfn> ### {#create-trusted-type-policy-algorithm}

To create a {{TrustedTypePolicy}} in a {{TrustedTypePolicyFactory|factory}},
given a DOMString (*policyName*) and policy options dictionary (*options*), run these steps:

1.  If *factory*'s `[[PolicyMap]]` internal slot has an entry with the key
    `policyName`, then throw a {{TypeError}}.
1.  Let *policyAllowed* be the result of running [$Is policy name allowed$] algorithm.
1.  If *policyAllowed* is False, throw a {{TypeError}}.
1.  If [$Is a default policy$] algorithm returns True and *exposed* is False, then
    throw a {{TypeError}}.
1.  Let *policy* be a new {{TrustedTypePolicy}} object.
1.  Set policy's `name` property value to *policyName*.
1.  Let *policyOptions* be a new {{TrustedTypePolicyOptions}} object.
1.  Set *policyOptions*
    {{TrustedTypePolicy/createHTML(input)|createHTML}} property to *option*'s
    {{TrustedTypePolicyOptions/createHTML|createHTML}} property value.
1.  Set *policyOptions* {{TrustedTypePolicy/createScript()|createScript}}
    property to *option*'s
    {{TrustedTypePolicyOptions/createScript|createScript}} property value.
1.  Set *policyOptions* {{TrustedTypePolicy/createScriptURL()|createScriptURL}}
    property to *option*'s
    {{TrustedTypePolicyOptions/createScriptURL|createScriptURL}} property value.
1.  Set *policyOptions* {{TrustedTypePolicy/createURL()|createURL}}
    property to *option*'s
    {{TrustedTypePolicyOptions/createURL|createURL}} property value.
1.  Set *policy*'s `[[options]]` internal slot value to *policyOptions*.
1.  Set the value for the *policyName* entry of *factory*'s `[[PolicyMap]]` to *policy*.
1.  Return *policy*.


### <dfn abstract-op>Get default policy</dfn> ### {#get-default-policy-algorithm}
To get the [=default policy=] for a *factory*, execute the following steps:

1.  Set *policyName* to `"default"`.
1.  If *factory*'s `[[PolicyMap]]` internal slot does not have an entry
    with the key *policyName*, return {{null}}.
1.  Otherwise, return the value of the *policyName* entry of
    *factory*'s `[[PolicyMap]]`.


### <dfn abstract-op>Is policy name allowed</dfn> ### {#is-policy-name-allow-algorithm}

Let *policyName* and *factory* be the same variables as those of the
same name in the algorithm that invoked these steps.

1.  Let *configuration* be the value of *factory*'s internal
    `[[Configuration]]` slot.
1.  If *configuration*'s
    {{TrustedTypeConfiguration/unknownPolicyName|unknownPolicyName}}'s
    is `"allow"`, return true.
1.  Otherwise, if *factory*'s `[[Configuration]]`'s
    {{TrustedTypeConfiguration/allowedNames|allowedNames}} set
    contains *policyName*, return true.
1.  Return false.


### <dfn abstract-op>Is a default policy</dfn> ### {#is-default-policy-algorithm}

Let *policyName* be the same variable as that of the same name in the
algorithm that invoked these steps.

1.  If *policyName* equals `"default"`, return true.
1.  Otherwise, return false.


### <dfn abstract-op>Create a Trusted Type</dfn> ### {#create-a-trusted-type-algorithm}

Given a {{TrustedTypePolicy}} |policy|, a type name |trustedTypeName|,
and a string |value|, execute the following steps:


1.  Let |functionName| be a function name for the given |trustedTypeName|,
    based on the following table:

    <table>
      <tr>
        <th>Function name</th>
        <th>Trusted Type name </th>
      </tr>
      <tr>
        <td>"createHTML"</td>
        <td>"TrustedHTML"</td>
      </tr>
      <tr>
        <td>"createScript"</td>
        <td>"TrustedScript"</td>
      </tr>
      <tr>
        <td>"createScriptURL"</td>
        <td>"TrustedScriptURL"</td>
      </tr>
      <tr>
        <td>"createURL"</td>
        <td>"TrustedURL"</td>
      </tr>
    </table>

1.  Let |options| be the value of |policy|'s `[[options]]` slot.
1.  Let |function| be the value of the property in |options| named |functionName|.
1.  If |function| is null, throw a {{TypeError}}.
1.  Let |policyValue| be the result of invoking |function| with
    |value| as a first argument, and [[ECMASCRIPT#sec-method|callback **this** value]]
    set to null.
1.  If |policyValue| is an error, return |policyValue| and abort the following steps.
1.  Let |dataString| be the result of stringifying |policyValue|.
1.  Let |trustedObject| be a new instance of an interface with a type
    name |trustedTypeName|, with its `[[Data]]` internal slot value
    set to |dataString|.
1.  Return |trustedObject|.

## Enforcement ## {#enforcement-algorithms}

### <dfn abstract-op>Obtain a Trusted Type Configuration for a response</dfn> ### {#obtain-a-trusted-type-configuration-for-a-response-algorithm}

This algorithm parses the [=Trusted-Types HTTP Response Header=] from
the response as a [[HTTP-JFV]] value and creates a configuration
object.  The header value consists of a list of values.
Every string value is assumed to be an
{{TrustedTypeConfiguration/allowedNames|allowed policy name}},
and the presence of the header by default
[=enforcement|enforces=] the types at every sink type.

Given a {{Response}} (|response|), perform the following steps:

1.  Let |config| be a new {{TrustedTypeConfiguration}}.
1.  Let |defaultSinkDisposition| be `“unsafe-allow”`.
1.  Let |hasWildcardPolicy| be true
1.  Let |header| be the value of the header in |response|’s <a>header list</a>
    whose name is `“Trusted-Types”`
1.  Let |list| be the result of executing the algorithm defined in
    Section 4 of [[HTTP-JFV]] on |header|. If that algorithm results
    in an error, abort these steps.

    Issue: A trailing comma should not disable enforcement.  Do we
    need to leave the document in a locked down state?
    Maybe set *config*.domSinks to "reject" and return *config*.
1.  If |list| is not empty, then set |hasWildcardPolicy| to {{false}} and set
    defaultSinkDisposition to `“reject”`.
1.  For each |item| in |list|:
    1.  If |item| is a <a href="https://tools.ietf.org/html/rfc8259#section-7">string</a> :
        1.  If |item| is equal to `“*”`, then set |hasWildcardPolicy| to true.
        1.  Otherwise, add |item| to |config|'s
            {{TrustedTypeConfiguration/allowedNames|allowedNames}} set.
    1.  Otherwise, if |item| is an
        <a href="https://tools.ietf.org/html/rfc8259#section-4">object</a>,
        for each |name| → |value| of |item|, execute the following steps:
        1.  Let |propertyName| be the result of running ASCII lowercase on name.
        1.  Execute the first statement, switching on |propertyName|:
            1.  case `“dom”`:
                If value is a valid {{StringAtSinkDisposition}}, set
                |defaultSinkDisposition| to that value. Otherwise, throw
                an error.
            1.  case `“report”`:
                If value is a
                <a href="https://tools.ietf.org/html/rfc8259#section-7">string</a>,
                set |config|'s
                {{TrustedTypeConfiguration/reportingGroup|reportingGroup}}
                to that value.
                Otherwise, throw an error.
            1.  Otherwise, continue.
    1.  Otherwise, throw an error.
1.  If |hasWildcardPolicy| is false, then set |config|'s
    {{TrustedTypeConfiguration/unknownPolicyName}} to `“reject”`.
1.  If |config|’s {{TrustedTypeConfiguration/domSinks|domSinks}} is {{null}},
    set |config|’s domSinks to |defaultSinkDisposition|’s value.
1.  Return |config|.


### <dfn abstract-op>Get Trusted Type compliant string</dfn> ### {#get-trusted-type-compliant-string-algorithm}

This algorithm will return a string that can be assigned to a DOM
[=injection sink=], optionally unwrapping it from a matching [=Trusted Type=].
It will ensure that the Trusted Type [=enforcement=] rules were respected.

Given a {{TrustedType}} type (|expectedType|), a {{Document}}
(|document|), and a {{TrustedType}} (|input|) run these steps:

1.  Let |disposition| be |document|’s {{TrustedTypeConfiguration}}'s
    {{TrustedTypeConfiguration/domSinks}}.
1.  If |disposition| is `“unsafe-allow”`, return stringified |input| and abort these steps.
1.  If |input| has type |expectedType|, return stringified
    |input| and abort these steps.
1.  Otherwise, execute the following steps:
    1.  Let |defaultPolicy| be the result of executing
        [$Get default policy$] algorithm on |document|’s
        [[HTML5#concept-document-bc|browsing context]]'s {{Window}}
        object.
    1.  If |defaultPolicy| is {{null}}, abort these steps.

        Issue: Do we need some "resume below" language?
    1.  Let |convertedInput| be the result of executing [$Create a
        Trusted Type$] algorithm, with the following arguments:
        *  |defaultPolicy| as |policy|
        *  |input| as |value|
        *  |expectedType|’s type name as |trustedTypeName|
    1.  If |convertedInput| is an error, then return error and abort the following steps.
    1.  If |convertedInput| has type |expectedType|, then return
        stringified |convertedInput| and abort the following steps.
    1.  Set |input| to |convertedInput|’s value.
1.  Execute [$Report sink type mismatch violation$] algorithm.
1.  If |disposition| is `“report”`, then return stringified |input| and abort these steps.
1.  Throw a {{TypeError}}.

### <dfn abstract-op>Enforce a Trusted Type</dfn> ### {#enforce-a-trusted-type-algorithm}

Enforce a Trusted Type algorithm describes a modification to the [=injection sinks=],
asserting that the input meets [=Trusted Type=]
restrictions set for the current {{Document}}.  It accepts an input
value that the original function would and will optionally
pass-through to the original function -- all original arguments to the
function apart from input are passed through without modification.

Given |input| and |expectedType|, perform the following steps.

1.  Let |compliantValue| be the result of executing [$Get Trusted Type
    compliant string$] algorithm with
    *  |document| being the current {{Document}}
    *  |input|
    *  |expectedType|

1.  If the previous algorithm throws an exception, rethrow the exception,
    and abort these steps.

    Issue: can we use "|compliantValue| is an error" language here?

1.  Execute the original function with |compliantValue| instead of the
    original value.  If the original functions accepts other
    arguments, pass-them through to the original function.  Return the
    result.

### <dfn abstract-op>Create a Violation for</dfn> ### {#create-a-violation-for-algorithm}

Issue: TODO: write and link to it

### <dfn abstract-op>Report sink type mismatch violation</dfn> ### {#report-sink-type-mismatch-violation-algorithm}

Issue: Check that this algorithm is complete.

Given a [[#violation|violation]] (|violation|), this algorithm reports
it to the {{TrustedTypeConfiguration/reportingGroup|endpoint}}
specified in the |violation|’s {{TrustedTypeConfiguration|configuration
object}}.

1.  Enqueue a task to run the following steps:
    1.  Let |group| be |violation|’s configuration's
        {{TrustedTypeConfiguration/reportingGroup}}.
    1.  Let |settings| be |violation|’s [[CSP3#violation-global-object|global object]]’s
        relevant settings object.
    1.  Execute [[REPORTING#queue-report|Queue data as type for endpoint group on settings algorithm]]
        with the following arguments:
        *  |data| = |violation|
        *  |type| = `“trusted-types”`
        *  |endpoint group| = |group|
        *  |settings| = |settings|

        Note: The optional |url| parameter is not provided.

# Integrations # {#integrations}

<pre class="idl">
typedef (DOMString or TrustedHTML) HTMLString;
typedef (DOMString or TrustedScript) ScriptString;
typedef (USVString or TrustedScriptURL) ScriptURLString;
typedef (USVString or TrustedURL) URLString;
typedef (TrustedHTML or TrustedScript or TrustedScriptURL or TrustedURL) TrustedType;

typedef (([TreatNullAs=EmptyString] DOMString) or TrustedHTML) HTMLStringDefaultsEmpty;
</pre>

Note: {{HTMLStringDefaultsEmpty}} is a non-nullable variant that accepts *null* on set.
Having this separate type allows [[webidl#TreatNullAs]] to attach to DOMString
per heycam/webidl#441.

Issue(WICG/trusted-types#2): [[webidl#TreatNullAs|TreatNullAs=EmptyString]] is confusing.
See note "It should not be used in specifications unless ...".
For some sinks a {{null}} value will result in "", and "null" for others.
This already caused problems in the polyfill.

## Integration with HTML ## {#integration-with-html}

{{Window}} objects have a {{Window/TrustedTypes|trusted type policy factory}},
which is a {{TrustedTypePolicyFactory}} object.

{{Document}} objects have a trusted type configuration,
which is a {{TrustedTypeConfiguration}} object.


### <dfn abstract-op>Initialize a Document’s trusted type configuration algorithm</dfn> ### {#initialize-a-documents-trusted-type-configuration-algorithm}

This algorithm should be executed during the
[[HTML5#initialise-the-document-object|Initializing a new Document
object]] algorithm.

Given a {{Document}} (*document*), a
[[HTML5#concept-document-bc|browsing context]] (*browsingContext*) and
a [[Fetch#response-class|response]] (*response*), the user agent performs the
following steps in order to initialize
[[#integration-with-html|*document*'s TrustedTypePolicyConfiguration]]:

1.  Let *configuration* be the result of executing the [$Obtain a Trusted
    Type Configuration for a response$] algorithm on *response*. If that
    algorithm results in an error, abort these steps.
1.  Set [[#integration-with-html|*document*'s TrustedTypePolicyConfiguration]]
    to *configuration*.
1.  Let *factory* be the result of executing the [$Initialize policy
    factory$] algorithm on *configuration*.
1.  Set *browsingContext*’s {{WindowProxy}} object's {{Window/TrustedTypes}}
    attribute to *factory*.



### Extensions to the Window interface ### {#extensions-to-the-window-interface}

This document extends the {{Window}} interface defined by [[HTML5|HTML]]:

<pre class="idl">
partial interface mixin Window {
  [Unforgeable] readonly attribute
      TrustedTypePolicyFactory TrustedTypes;

  WindowProxy? open(
      [TrustedTypes=TrustedURL] optional URLString url = "about:blank",
      optional DOMString target = "_blank",
      optional ([TreatNullAs=EmptyString] DOMString) features = "");
};
</pre>

{{Window/TrustedTypes}} returns the [[#integration-with-html|trusted
type policy factory]] of the current {{Window}}, if the current Window
has a trusted type policy factory, or {{null}} otherwise.

### Extensions to the Document interface ### {#extensions-to-the-document-interface}

This document modifies the {{Document}} interface defined by [[HTML5|HTML]]:

<pre class="idl">
partial interface mixin Document {
  WindowProxy? open([TrustedTypes=TrustedURL] URLString url, DOMString name, DOMString features);
  [CEReactions] void write([TrustedTypes=TrustedHTML] HTMLString... text);
  [CEReactions] void writeln([TrustedTypes=TrustedHTML] HTMLString... text);
};
</pre>

Note: This document does not affect the two argument form of
[[HTML/dynamic-markup-insertion#dom-document-open|document.open]].

### Extensions to the Location interface ### {#extensions-to-the-location-interface}

This document modifies the {{Location}} interface defined by [[HTML5|HTML]]:

<pre class="idl">
partial interface mixin Location {
  [Unforgeable, TrustedTypes=TrustedURL] stringifier attribute URLString href;
  [Unforgeable] void assign([TrustedTypes=TrustedURL] URLString url);
  [Unforgeable] void replace([TrustedTypes=TrustedURL] URLString url);
};
</pre>

### Enforcement in element attributes ### {#enforcement-in-sinks}

This document modifies following IDL attributes of various DOM elements:

<pre class="idl">
partial interface mixin HTMLScriptElement : HTMLElement {
  [CEReactions, TrustedTypes=TrustedScriptURL] attribute ScriptURLString src;
  [CEReactions, TrustedTypes=TrustedScript] attribute ScriptString text;
};

partial interface mixin HTMLIFrameElement : HTMLElement {
  [CEReactions, TrustedTypes=TrustedURL] attribute URLString src;
  [CEReactions, TrustedTypes=TrustedHTML] attribute HTMLString srcdoc;
};

partial interface HTMLEmbedElement : HTMLElement {
  [CEReactions, TrustedTypes=TrustedScriptURL] attribute ScriptURLString src;
};

partial interface HTMLObjectElement : HTMLElement {
  [CEReactions, TrustedTypes=TrustedScriptURL] attribute ScriptURLString data;
  [CEReactions, TrustedTypes=TrustedScriptURL] attribute DOMString codeBase; // obsolete
};

partial interface HTMLLinkElement : HTMLElement {
  [CEReactions, TrustedTypes=TrustedURL] attribute URLString href;
};

partial interface HTMLFrameElement : HTMLElement { // obsolete
  [CEReactions, TrustedTypes=TrustedURL] attribute URLString src;
};

partial interface HTMLImageElement : HTMLElement {
  [CEReactions, TrustedTypes=TrustedURL] attribute URLString src;
};

partial interface HTMLFormElement : HTMLElement {
  [CEReactions, TrustedTypes=TrustedURL] attribute URLString action;
};

partial interface HTMLInputElement : HTMLElement {
  [CEReactions, TrustedTypes=TrustedURL] attribute URLString formAction;
  [CEReactions, TrustedTypes=TrustedURL] attribute URLString src;
};

partial interface HTMLButtonElement : HTMLElement {
  [CEReactions, TrustedTypes=TrustedURL] attribute URLString formAction;
};

partial interface mixin HTMLHyperlinkElementUtils {
  [CEReactions, TrustedTypes=TrustedURL] stringifier attribute URLString href;
};

partial interface HTMLBaseElement : HTMLElement {
  [CEReactions, TrustedTypes=TrustedURL] attribute URLString href;
};

partial interface HTMLMediaElement : HTMLElement {
  [CEReactions, TrustedTypes=TrustedURL] attribute URLString src;
};

partial interface HTMLSourceElement : HTMLElement {
  [CEReactions, TrustedTypes=TrustedURL] attribute URLString src;
};

partial interface HTMLTrackElement : HTMLElement {
  [CEReactions, TrustedTypes=TrustedURL] attribute URLString src;
};

// TODO: Add HTMLPortalElement.src from https://github.com/WICG/portals once it's specced.
</pre>

### Enforcement for script child text contents ### {#enforcement-in-script-text}

This document modifies how {{HTMLScriptElement}} [=child text content=] can be set to allow documents to control dynamically created scripts. It does so by
adding the {{HTMLElement/innerText}} and {{Node/textContent}} attributes directly on {{HTMLScriptElement}}. The behavior of the attributes remains the same
as in their original counterparts, apart from additional behavior triggered by the {{TrustedTypes}} extended attribute presence.

<pre class="idl">
partial interface mixin HTMLScriptElement : HTMLElement {
 [CEReactions, TrustedTypes=TrustedScript] attribute [TreatNullAs=EmptyString] ScriptString innerText;
 [CEReactions, TrustedTypes=TrustedScript] attribute ScriptString? textContent;
};
</pre>

Issue(WICG/trusted-types#133): Define more generic restrictions for script texts.

### Enforcement in timer functions ### {#enforcement-in-timer-functions}

This document modifies the {{WindowOrWorkerGlobalScope}} interface mixin:

<pre class="idl">
typedef (ScriptString or Function) TrustedTimerHandler;

partial interface mixin WindowOrWorkerGlobalScope {
  long setTimeout(TrustedTimerHandler handler, optional long timeout = 0, any... arguments);
  long setInterval(TrustedTimerHandler handler, optional long timeout = 0, any... arguments);
};
</pre>

To the [[HTML5#timer-initialisation-steps|timer initialization steps algorithm]],
add this step between 7.1 and 7.2:

1.  If the first operation argument is not a {{Function}}, or if the first operation argument is a {{TrustedType}}, set the first operation argument to the result of executing
    the [$Get Trusted Type compliant string$] algorithm, with
    *   *document* set to the document of the method content proxy.
    *   *input* set to the first method argument, and
    *   *expectedType* set to {{TrustedScript}}.

Note: This makes sure that a {{TrustedScript}} is passed to timer
functions in place of a string when Trusted Types are enforced, but
also unconditionally accepts any {{Function}} object.

### Enforcement in event handler content attributes ### {#enforcement-in-event-handler-content-attributes}

This document modifies the
[[HTML5#event-handler-content-attributes|attribute change steps for an event handler content attribute]].

At the beginning of step 5, insert the following steps:

1.  Let *value* be the result of executing the
    [$Get Trusted Type compliant string$] algorithm, with
    *   *document* set to the owner document of *eventTarget*,
    *   *input* set to *value*,
    *   *expectedType* set to {{TrustedScript}}, and
    *   *passThroughFunctions* set to false.
1.  If the algorithm throws an error, abort these steps.


## Integration with DOM Parsing ## {#integration-with-dom-parsing}

This document modifies the following interfaces defined by [[DOM-Parsing]]:

<pre class="idl">
partial interface Element {
  [CEReactions, TrustedTypes=TrustedHTML] attribute HTMLStringDefaultsEmpty outerHTML;
  [CEReactions] void insertAdjacentHTML(DOMString position, [TrustedTypes=TrustedHTML] HTMLString text);
};

partial interface mixin InnerHTML { // specified in a draft version at https://w3c.github.io/DOM-Parsing/#the-innerhtml-mixin
  [CEReactions, TrustedTypes=TrustedHTML] attribute HTMLStringDefaultsEmpty innerHTML;
};

partial interface Range {
  [CEReactions, NewObject] DocumentFragment createContextualFragment([TrustedTypes=TrustedHTML] HTMLString fragment);
};

[Constructor, Exposed=Window]
interface DOMParser {
  [NewObject] Document parseFromString([TrustedTypes=TrustedHTML] HTMLString str, SupportedType type);
};
</pre>

## Integration with Content-Security-Policy ## {#integration-with-content-security-policy}

Note: See <a href="https://github.com/tc39/ecma262/issues/938">TC39/ecma262 issue #938</a>
(adding the value to be compiled to algorithm parameters).

This document modifies the [[CSP3#can-compile-strings|EnsureCSPDoesNotBlockStringCompilation]]
which is reproduced in its entirety below with additions and deletions.

<div class="note">Note: EcmaScript code may call `Function()` and `eval` cross realm.
<pre highlight="js">
  let f = new self.top.Function(source);
</pre>
In this case, the |callerRealm|'s Window is `self` and the |calleeRealm|'s Window is `self.top`.
The Trusted Types portion of this algorithm uses |calleeRealm| for consistency with other sinks.
<pre highlight="js">
  // Assigning a string to another Realm's DOM sink uses that Realm's default policy.
  self.top.body.innerHTML = 'Hello, World!';
  // Using another Realm's builtin Function constructor should analogously use that
  // Realm's default policy.
  new self.top.Function('alert(1)')()
</pre>
This is subtly different from the CSP directive enforcement portion which rejects if either
the |calleeRealm| or |callerRealm|'s Content-Security-Policy rejects string compilation.
</div>

Given two [[ECMASCRIPT#realm|realms]] (|callerRealm| and
|calleeRealm|), and a <del>string</del> <ins>value</ins>
(|source|), this algorithm returns <del>normally</del>
<ins>the source string to compile</ins> if compilation is allowed, and
throws an "`EvalError`" if not:

1.  <ins>Let |document| be |calleeRealm|’s
    [[HTML5#environment-settings-object|environment setting object]]'s
    [[HTML5#responsible-document|responsible document]].</ins>

2.  <ins>Let |sourceString| be the result of executing the
    [$Get Trusted Type compliant string$] algorithm, with:
    *   |document| as |document|,
    *   |source| as |input|,
    *   {{TrustedScript}} as |expectedType|, and
    *   false as |passThroughFunctions|.</ins>

3.  <ins>If the algorithm throws an error, throw an {{EvalError}}.</ins>

4.  Let |globals| be a list containing |calleeRealm|'s [=Realm/global object=] and |calleeRealm|'s
    [=Realm/global object=].

5.  <ins>Let |cspPolicies| be an empty list.</ins>

6.  <ins>For each |global| in |globals|:

    1.  For each |policy| in |global|'s [[CSP#global-object-csp-list|CSP list]]:
        1.  Add |policy| to |cspPolicies|.</ins>

7.  <ins>Let |isExempt| be the result of executing the [$IsSourceExempt$] algorithm with:
    *   |cspPolicies| as |cspPolicies|, and
    *   |document|’s {{TrustedTypeConfiguration}} as |ttConfig|.</ins>

8.  <ins>If |isExempt| is true, then return |sourceString|.</ins>

9.  For each |global| in |globals|:

    1.  Let |result| be "`Allowed`".

    2.  For each |policy| in |global|'s [[CSP#global-object-csp-list|CSP list]]:

        1.  Let |source-list| be `null`.

        2.  If |policy| contains a [=directive=] whose [=directive/name=] is "`script-src`", then
            set |source-list| to that [=directive=]'s [=directive/value=].

            Otherwise if |policy| contains a [=directive=] whose [=directive/name=] is
            "`default-src`", then set |source-list| to that directive's [=directive/value=].

        3.  If |source-list| is not `null`, and does not contain a [=source expression=] which is
            an [=ASCII case-insensitive=] match for the string "<a grammar>`'unsafe-eval'`</a>",
            then:

            1.  Let |violation| be the result of executing [[CSP3#create-violation-for-global]] on
                |global|, |policy|, and "`script-src`".

            2.  Set |violation|'s [=violation/resource=] to "`inline`".

            3.  If |source-list| [=list/contains=] the expression
                "<a grammar>`'report-sample'`</a>", then set |violation|'s [=violation/sample=] to
                the substring of <del>|source|</del> <ins>|sourceString|</ins> containing its first
                40 characters.

            4.  Execute [[CSP3#report-violation]] on |violation|.

            5.  If |policy|'s [=policy/disposition=] is "`enforce`", then set |result| to
                "`Blocked`".

    3.  If |result| is "`Blocked`", throw an `EvalError` exception.

10. <ins>Return |sourceString|.</ins>

Note: returning |sourceString| means that the string that gets
compiled is that returned by any [=default policy=] in the course of
executing [$Get Trusted Type compliant string$].

Issue: This depends on a solution to
<a href="https://github.com/WICG/trusted-types/issues/144">issue #144</a> like <a
href="https://mikesamuel.github.io/proposal-hostensurecancompilestrings-passthru/">TC39 HostBeforeCompile</a>

Issue: In some cases, the violation "`'report-sample'`" contain the result of
applying the default policy to a string argument which differs.
Specifically when, there is a [=default policy=], |isExempt| is false,
and |source| there is a CSP policy for either the |callerRealm|
or |callerRealm| that disallows "`'unsafe-eval'"`.
Is this a feature or a bug?

Note: The previous algorithm reports violations via both report-uris where
callerRealm != calleeRealm.  If [$Get Trusted Type compliant string$] reports an
error, it only reports it via its |calleeRealm|'s report-uri.


### <dfn abstract-op>IsSourceExempt</dfn> Algorithm ### {#is-source-exempt-algorithm}

The IsSourceExempt algorithm takes a list of
[[CSP3#content-security-policy-object|policies]] (|cspPolicies|),
and a {{TrustedTypeConfiguration}} (|ttConfig|) and executes the
following steps:

1.  Let |isTTStrict| = `true`.
1.  If |ttConfig|'s {{TrustedTypeConfiguration/unknownPolicyName}} is
    {{UnknownPolicyNameDisposition|"allow"}} then
    set |isTTStrict| to `false`.
1.  Otherwise if |ttConfig|'s {{TrustedTypeConfiguration/allowedNames}} contains `'*'` then
    set |isTTStrict| to `false`.
1.  Let |isTTEnforced| = `false`.
1.  If |ttConfig|'s {{TrustedTypeConfiguration/domSinks}} is
    {{StringAtSinkDisposition|"reject"}} then
    set |isTTEnforced| to `true`.
1.  Let |isCSPEnforced| = `false`.
1.  For each |policy| in |cspPolicies|:
    1.  Let |source-list| be `null`.
    1.  If |policy| contains a [[CSP3#directive|directive]]
        whose [[CSP3#directive-name|name]] is "`script-src`", then set
        |source-list| to that [[CSP3#directive|directive]]'s
        [[CSP3#directive-value|value]].

        Otherwise if |policy| contains a [[CSP3#directive|directive]]
        whose [[CSP3#directive-name|name]] is "`default-src`", then set
        |source-list| to that [[CSP3#directive|directive]]'s
        [[CSP3#directive-value|value]].
    1.  If |source-list| is not `null`, and does not contain a
        [[CSP3#source-expression|source expression]] which as an
        <a>ASCII case-insensitive</a> match for
        the string "<a grammar>'unsafe-eval'</a>", then
        set |isCSPEnforced| to `true`.
1.  If |isTTStrict| is `true` and |isCSPEnforced| is equal to
    |isTTEnforced| then return `true`.
1.  Return `false`.

Note: We want to allow progressive enhancement via dynamic code loading
without requiring servers to serve `'unsafe-eval` only to user-agents
that don't implement TrustedTypes without allowing
{{TrustedTypePolicyFactory/createPolicy()}} to bypass CSP without opt-in.
This algorithm returns true if CSP and TrustedTypes agree on whether
to enforce and the {{TrustedTypeConfiguration}} places meaningful limits
(|isTTStrict|) on {{TrustedTypePolicy}} creation.


# Security Considerations # {#security-considerations}

Trusted Types are not intended to defend against XSS in an actively malicious
execution environment. It's assumed that the application is written by
non-malicious authors; the intent is to prevent developer mistakes that could
result in security bugs, and not to defend against first-party malicious code actively trying to bypass policy restrictions.

## Bypass vectors ## {#bypass-vectors}

Issue(WICG/trusted-types#49): Mention node-adoption bypass vectors.

Issue(WICG/trusted-types#64): Mention anchor element properties bypass.


Issue(WICG/trusted-types#47): Mention text/attribute node copy bypass vectors.

Issue(WICG/trusted-types#42): Mention bypass vectors with template elements.

Issue(WICG/trusted-types#6): Mention corner cases with types that depend on a different attribute value.

## Best practices for policy design ## {#best-practices-for-policy-design}

Trusted Types limit the scope of the code that can introduce DOM XSS
vulnerabilities to the implementation of [[#policies|policies]]. In this design,
insecure policies can still enable XSS. Special emphasis needs to be taken by
use policies that are either secure for all possible inputs, or limit the access
to insecure policies, such that they are only called with non-attacker
controlled inputs.

Issue(WICG/trusted-types#78): Mention the policy is global state-dependant.

Issue: Refer to the external document on secure policy design.

# Implementation Considerations # {#implementation-considerations}

## Vendor-specific Extensions and Addons ## {#vendor-specific-extensions-and-addons}

Restriction imposed by the {{TrustedTypeConfiguration}} objects SHOULD
NOT interfere with the operation of user-agent features like addons,
extensions, or bookmarklets. These kinds of features generally advance
the user’s priority over page authors, as espoused in
[[html-design-principles]]. Specifically, extensions SHOULD be able to pass strings
to the DOM XSS [=injection sinks=] of the document without triggering [=default policy=]
execution, [[#violation|violation]] generation, or the rejection of the value.
